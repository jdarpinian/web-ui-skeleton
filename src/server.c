/*
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdint.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>
#include "pal.h"
#include "server.h"
#include "../third_party/mongoose/mongoose.h"


void print_usage_and_exit() {
  fprintf(stderr, "usage: server\n");
  fprintf(stderr, "No options yet.\n");
  exit(1);
}


void parse_flags(int argc, const char **argv, command_line_flags *flags) {
  memset(flags, 0, sizeof(*flags));

  int c;

  // TODO: Use getopt_long instead.
  while ((c = getopt(argc, (char **)argv, ":")) != -1) {
    switch(c) {
    // No options yet.
    case ':':
      fprintf(stderr, "Option -%c requires an operand\n", optopt);
      print_usage_and_exit();
      break;
    case '?':
      fprintf(stderr, "Unrecognized option: '-%c'\n", optopt);
      print_usage_and_exit();
    }
  }

  // TODO: Validate the options.
}


// Serve files from the ./html directory.
char *document_root = "html";
struct mg_context *mongoose = NULL;

// This function is defined in the file generated by files-to-c-arrays.py
const char *get_file(const char *path, size_t *out_size);

// Satisfies the HTTP request from memory, or returns a 404 error. The
// filesystem is never touched.
// Ideally we'd use Mongoose's open_file callback override to implement file
// serving from memory instead, but that method provides no way to disable
// caching or display directory index documents.
static void serve_file_from_memory_or_404(struct mg_connection *connection) {
  const struct mg_request_info *request_info = mg_get_request_info(connection);
  const char *uri = request_info->uri;
  // If the root of the server is requested, display the index instead.
  if (strlen(uri) < 2) {
    uri = "/index.html";
  }
  // Construct the file's full path relative to the document root.
  const int max_path = 2048;
  char file_path[max_path];
  size_t path_length = strlen(uri) + strlen(document_root) + 1;
  const char *file = NULL;
  size_t file_size = 0;
  if (path_length < max_path) {
    snprintf(file_path, path_length, "%s%s", document_root, uri);
    file = get_file(file_path, &file_size);
  }
  if (file) {
    // We've located the file in memory. Serve it with headers to disable
    // caching.
    mg_printf(connection, "HTTP/1.1 200 OK\r\n"
              "Cache-Control: no-cache\r\n"
              "Content-Type: %s\r\n"
              "Content-Length: %lu\r\n"
              "Connection: close\r\n\r\n",
              mg_get_builtin_mime_type(file_path),
              file_size);
    mg_write(connection, file, file_size);
  } else {
    // The file doesn't exist in memory.
    mg_printf(connection, "HTTP/1.1 404 Not Found\r\n"
              "Cache-Control: no-cache\r\n"
              "Content-Type: text/plain; charset=utf-8\r\n"
              "Content-Length: 25\r\n"
              "Connection: close\r\n\r\n"
              "Error 404: File not found");
  }
}


// The number of pages holding open keep-alive requests to the server is stored
// in this global counter, updated with atomic increment/decrement instructions.
// When it reaches zero the server will exit.
volatile long keep_alives = 0;

static int mongoose_begin_request_callback(struct mg_connection *connection) {
  const struct mg_request_info *request_info = mg_get_request_info(connection);
  if (strcmp(request_info->uri, "/keepServerAlive") == 0) {
    __sync_fetch_and_add(&keep_alives, 1);
    mg_printf(connection, "HTTP/1.1 200 OK\r\n"
              "Access-Control-Allow-Origin: *\r\n"
              "Content-Type: application/octet-stream\r\n"
              "Cache-Control: no-cache\r\n"
              "Transfer-Encoding: chunked\r\n\r\n");
    const int chunk_size = 6;
    char *chunk = "1\r\n0\r\n";
    const int warmup_chunks = 2048;
    for (int i = 0; i < warmup_chunks; i++) {
      mg_write(connection, chunk, chunk_size);
    }
    while(true) {
      if (!mg_write(connection, chunk, chunk_size)) break;
      usleep(1000 * 1000);
    }
    __sync_fetch_and_add(&keep_alives, -1);
    return 1;
  } else {
#ifdef NDEBUG
    // In release mode, we embed the test files in the executable and serve
    // them from memory. This makes the test easier to distribute as it is
    // a standalone executable file with no other dependencies.
    serve_file_from_memory_or_404(connection);
    return 1;
#else
    // In debug mode, we serve the test files directly from the filesystem for
    // ease of development. Mongoose handles file serving for us.
    return 0;
#endif
  }
}


// This is the entry point called by main().
void run_server(command_line_flags *flags) {
  assert(mongoose == NULL);
  srand((unsigned int)time(NULL));
  const char *options[] = {
    "listening_ports", "5578",
    "document_root", document_root,
    // Forbid everyone except localhost.
    "access_control_list", "-0.0.0.0/0,+127.0.0.0/8",
    // We have a lot of concurrent long-lived requests, so start a lot of
    // threads to make sure we can handle them all.
    "num_threads", "32",
    NULL
  };
  struct mg_callbacks callbacks;
  memset(&callbacks, 0, sizeof(callbacks));
  callbacks.begin_request = mongoose_begin_request_callback;

  mongoose = mg_start(&callbacks, NULL, options);
  if (!mongoose) {
    debug_log("Failed to start server.");
    exit(1);
  }
  usleep(0);

  if (!open_browser("http://localhost:5578/")) {
    debug_log("Failed to open browser.");
  }
  // Wait for an initial keep-alive connection to be established.
  int64_t start_time = get_nanoseconds();
  while(keep_alives == 0) {
    usleep(1000 * 1000);
  }
  // Wait for all keep-alive connections to be closed.
  while(keep_alives > 0) {
    // NOTE: If you are debugging using GDB or XCode, you may encounter signal
    // SIGPIPE on this line. SIGPIPE is harmless and you should configure your
    // debugger to ignore it. For instructions see here:
    // http://stackoverflow.com/questions/10431579/permanently-configuring-lldb-in-xcode-4-3-2-not-to-stop-on-signals
    // http://ricochen.wordpress.com/2011/07/14/debugging-with-gdb-a-couple-of-notes/
    usleep(1000 * 100);
  }
  mg_stop(mongoose);

  mongoose = NULL;
}
